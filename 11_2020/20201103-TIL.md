# 오늘 공부할 내용

- HTML day 5 수업
- HTML day 4~5 수업 복습
- Java day3 수업 복습

# 오늘 공부한 것 & 배운 내용

- 등원 시간 공부

  - 개발자 취업 관련 유튜브
    - 이베이코리아 센터장 인터뷰 중 면접 중 우리 회사에 왜 오느냐는 질문을 꼭 한다고 하는데 본인이 회사에서 하고 싶은 것이 분명히 말하고 그 회사가 본인과 맞는지 확인하는 과정이라고 하셨다
      - 내가 왜 이회사에 가고 싶은지를 어떤 이유가 명확하게 있고 또 그것을 명학히 표현할 수 있는 능력이 필요한 것 같다. 그게 그 회사랑 잘맞아서 합격하고 불합격하고를 떠나서 자기자신에게도 중요한 부분 같고 단순히 회사에서 나를 뽑아주는것이 아닌 회사와 내가 파트너쉽을 통해 서로 윈윈할 수 있는 관계라는 것이 마음속에서 설정되어야 취직활동을 넘어 회사생활자체에도 목표와 의미가 생길 것 같다
  
- 준비 시간

  - 채용공고
    - 채용공고를 보면 자격요건을 보기 바빴는데 이회사가 어떤회사이고 어떤서비스를 하는지 살펴보는 것도 중요한것 같다. 이력서에 면접시에 사용해야되서 하는 것일수도있지만 좀더 본질적으로는 실제 내가 그 회사의 서비스에 공감할 수 있고 또 그회사와 같이 일하고 싶은지에 대한 것들을 알아볼수있는 기회가 되는 것 같기 때문이다
      - 이런 관점에서 채용공고를 보다보면 점점 내가 어떤 기업에서 일하고싶은지 그리고 그런정보를 어떻게 더 알아볼수있는지 아는데 도움이 될 것 같다
  
- HTML 복습

  - day4~5 수업 

    - 수업 요약: 웹카페 예제 중 gropu2에 해당하는 검색 폼, 탭메뉴, 새소식 영역을 구조설게와 디자인설게 및 실습을 진행하였다

    - 내용 정리:
      - 검색 메뉴
        - 반복되는 내용이지만 구조 설계는 논리적인 순서 -> 시멘틱 마크업 -> 네이밍-> 구조도 그려보기로 이어진다
          - 논리적인 순서는 컨텐츠를 중심으로 짜게 된다
          - 새로운 컨텐츠 블록이 시작되면 제목을 주면 된다
        - from 에 action속성은 form이 전송될 서버의 url을 뜻하고 name은  전송될때 값이 담길 이름(변수명하고 비슷한거 같다)
          - form은 fieldset으로 묶어주고 filedset을 설명한 legend를 달아준다.
          - input은 꼭 label을 작성하고 id로 서로를 연결해야 한다.
        - 검색 폼이기 때문에 input에 type을 search로 해주어야 한다
          - placeholder를 label처럼 사용해서는 안되고 input의 보조의 역할로만 사용해야 한다.(몇번 반복되서 강조하심)
          - requied는 input에 값을 꼭 입력하게 해주는 논리속성으로 rquired를 작성한다
            - xhtml 방식은 논리속성만이 아닌 속성과 값으로 이뤄어지게 rquied="requied"으로 작성해주는게 더바람직하다
          - name은 서버에 보낼 때 담아갈 container로 백엔드에서 filed에 담길값이 된다.
        - button은 buton을 꾸미는 것이 아닌 안에 span을 넣어서 span을 꾸미는 것이 일반적이다
        - display: flex를 통해 요소들을 가로로 쉽게 배치할 수 있다
          - flexgrow를 통해 특정사이즈를 주지 않고 남는 사이즈만큼 자리를차지하게 만들 수 있다
          - http://tcpschool.com/css/css3_expand_flexbox flex의 속성에 관한 참고자료

      - 탭 메뉴

        - 날짜 형식은 time 태그를 이용해서 입력한다
          - 입력받은 날짜들은 나중에 함수로 처리하게 된다
        - 더보기 버튼은 두번째로 작성할 것 같지만 논리적순서상 가장 마지막에 와야되니 가장마치막에 배치하고 css로 해당위치로 이동시킨다
        - 두 개의 탭을 만들고 activate된 tab만 활성화 할때는 class추가로 만들어 동적으로 할당해주는 기법을 사용한다
          - 평소에는 display: none 했다가 tab-act라는 클래스가 동적 할당 되면 보이도록 속성을 적용해주는 방식이었다
          - 동적할당은 Javascript를 사용하기 때문에 구현해보진 않았지만 동작원리는 이해할 수 있었다
        - 레이아웃을 할때 알고있는 우리가 배운 방법인 float, flex, position을 활용하면서 하되 똑같은 결과가 있더라도 어떤게 나중에 유지보수 할때 유리할지 고민하면서 선택해야 한다
          - 레이아웃을 한곳이나 근처에 자료가 더 추가되서 레이아웃을 변경할 때 어떤게 더 변경하사항을 줄이면서 할수있을지 고민해보라고 하셨다.
          - 예제에서도 처음엔 flex로 구현하다가 게시글이 늘어나는 시나리오를 추가하고 inline-block으로 만들어서 레이아웃을 하였다
        - tab을 나열하기위해 2개의 tab을 absoulte로 띄운 후 하나에만 위치좌표를 주어 다른 탭 옆에 배치되도록 하였다

      - 새소식 메뉴

        - article 태그를 통해 정보를 담고 있는 내용들을 묶어줄 수 있다

          - article을 위한 제목도 필요하기 때문에 하위 제목 테그인 h3같은걸 사용할 수 있다

        - 글 내용은 p태그를 활용해서 묶어줄 수 있다

        - 썸네일 같은 이미지를 담기 위해선 figure태그를 사용할수 있고 figcaption을 통해 설명을 달 수 있다

        - 중간이 디자인을 위한 선은 다양한 방법이 있겠지만 이번 예제에서는 가상 컨테이너를 만들고 posion을 이용하여 띄운 이후 위치를 조정하여 표현하는 방식을 사용했다

        - 썸네일이 들어갈 자리를 다른 기법이 아닌 padding을 줌으로써 확보하고 thumbnail을 position을 활용해 배치하는 방식으로 하였다

          - 이렇게 상황에 따라서 여러가지 방식을 통해서 레이아웃 할 수있다는 점이 css가 어려운 점이자 또 매력적인 부분인 것 같다

        - thumbnail 이미지는 box-shadow라는 속성을 사용해 그림자 효과를 주어 약간 띄워져 있는 효과를 주었다

          

    - 마지막으로 새로운 예제와 함께 form태그를 연습하기 위해 회원가입 예제를 하나 더 진행했으나 촉박한 시간 때문에 빠르게 진행되서 이런 내용이 있다는걸 배우는 정도로 보고 마무리하게 되었다

      

    - 배운점 :

      - css를 잘다뤄야지 마크업을 논리적인 순서로하고 이곳저곳에 디자인 따라서 레이아웃을 짤 수 있게 된다. css실력이 받쳐줘야 깔끔한 마크업이 나온다는 것 계속 반복되서 배우는 것 같다
      - html은 논리적으로 순서대로 해당 콘텐츠에 맞는 태그와 속성을 적절하게 사용하는 것이 중요하다는 것을 수업전반에 걸쳐 배울 수 있었다
        - 이렇게 함으로 코드의 가독성이 좋아지고 다양한 환경에서 접근하는 사용자 경험에 도움이 된다.

    

  - Java 복습

    - 보강 day1내용 복습

      - 수업 요약 : 멀티스레드 프로그래밍의 개념과 기본 사용방법에 대해 배웠다.

      - 내용 정리 및 보충 :

        - 멀티스레드

          - 프로세스와 스레드
            - 프로그램: 실행하면 OS로 부터 메모리가 할당되서 해당 메모리영역에 상주하면서 동작하게 되는데 그것을 프로세스라고 한다
            - 스레드:  프로세스의 동작단위로 하나의 프로세스는 여러개의 스레드를 가질 수 있다.(최소 하나의 스레드를 가진다)
              - 여러개의 스레드를 사용하는 프로그래밍 기법을 프로그래밍이라고한다.
          - 멀티스레드의 장단점
            - 장점: 여러 동작을 병렬적으로 처리하여 CPU 사용률을 향상 시켜 처리속도를 향상 시킬 수 있다
              - 주로 인코딩, 렌더링, 배치 작업등 cpu가 하나의 작업에만 집중하면서 오래 걸리는 작업들에 사용된다
            - 단점: 프로그램을 최적화 하는 것이기에 구현이 어렵고 여러개의 스레드가 동시에 동작하기에 디버깅 하기가 어렵다
              - 잘못 구현하면 오히려 스레드를 switching하는 과정에서 오버헤드가 발생하여 더 느려질 수 있다
          - 멀티스레드의 실행 방식
            - 동시성(Concurrency) : 멀티 작업을 위해 **하나의 코어**에서 멀티 스레드가 번갈아가며 실행하는 것
            - 병렬성(Paralleism) : 멀티 작업을 위해 **멀티 코어**에서 개별 스레드를 동시에 실행하는 것
              - Stream API에 병렬처리하는게 대표적인 예이다.
            - 참고자료: https://blog.naver.com/PostView.nhn?blogId=qbxlvnf11&logNo=220837131449&parentCategoryNo=&categoryNo=12&viewDate=&isShowPopularPosts=false&from=postView
          - 스레드의 특징
            - Thread의 객체는 1회용으로 .start()메소드를 통해 실행할 수 있고 해당 객체를 한번 사용하면 다시 사용할 수 없다
            - Thread에는 1부터 10에 Priority가 존재하고 기본값은 5이다.
              - 높아질 수록 스레드의 우선순위가 높아진다.
          - 스레드의 상태
            - 스레드 스케줄링 : 스레드의 개수가 코어(CPU)의 수보다 많을 경우, 스레드를 어떤 순서에 의해 동시성으로 실행할 것인가를 정하는 작업
            - 실행 대기상태 : 아직 스케줄링이 되지 않아서 실행을 기다리고 있는 상태
            - 실행 상태: 실행 대기 상태에 있는 스레드 중에서 스레드 스케줄링으로 선택된 스레드가 CPU를 점유하고 run()메소드를 실행하는 상태
              - 스레드는 start()메소드를 호출하면 곧바로 스레드가 실행되는 것이 아닌 실행 대기 상태가 된다. 실행 대기 상태에 있는 스레드 중에서 스레드 스케줄링으로 선택된 스레드만이 실행 상태가 된다. 실행 상태의 스레드는 run()메소드를 모두 실행하기 전에 스레드 스케줄링에 의해 다시 실행 대기 상태로 돌아갈 수 있다. 그리고 실행 대기 상태에 있는 스레드가 선택되어 실행 상태가 된다
            - 종료 상태: run() 메소드가 종료되어 더 이상 실행할 코드가 없어져 스레드의 실행을 멈추는 것
              - 조금씩 나누어서 실행하다가 실행할 코드가 없으면 스레드가 종료된다
            - 일시 정지 상태: 스레드가 실행할 수 없는 상태로 WAITING, TIMED_WAITING, BLOCKED의 세 가지 상태가 존재한다
            - 참고자료 : https://blog.naver.com/qbxlvnf11/220921178603
          - 스레드의 제어
            - sleep() 스레드를 해당 시간동안 일시정지 한뒤에 다시 대기상태가 된다
              - 대기시간도 있기 때문에 오버헤드가 yield()보다 크다
            - join() 해당 스레드의 동작이 종료될 때까지 기다렸다가 다른 작업을 수행한다 -> 스레드 동기화에 사용 될 수 있다
              - 언제까지 기다리게 할 것인지 시간을 지정할 수 있다
              - https://www.javatpoint.com/join()-method 참고자료
            - setPriority를 통해 스레드의 우선순위를 조정한다
              - OS에서도 자동으로 스레드들의 priority를 조정하기 때문에 조정해도 큰차이를 느낄 수 없다
            - yield() 다른 스레드에 양보하고 바로 실행대기(sleep(0)과 같이)
              - 대기 상태에서 바로 다음에 동작할 수도 있다 
              - 자주 스레드가 변한다는 것은 오버헤드가 자주 발생해서 수행속도가 느려진다
            - interrupt()는 sleep하고 있는 스레드를 interrupt 예외를 발생시켜 대기상태로 만들수 있다
              - 잘못 설정되어  오랫 동안 sleep하는 스레드들을 깨우는 역할이다.
          - 데몬 스레드
            - 다른 스레드가 종료될 경우 함께 종료되는 보조 스레드 보통 대기하며 동작하는 무한 루프로 구현 한다
              - 생성자에 setDaemon() 메소드로 데몬 스레드로 설정할 수 있다.
              - 예제에서는 시간마다 자동 저장되는 곳에 사용되었다.
          - 데이터 공유와 동기화
            - 스레드간 데이터 공유 시 신뢰성에 문제가 발생할 수 있다
              - 왜그런지는 조금더 보충해야 될 것 같다
              - 객체가 intrinsic lock(고유 락)을 가진 스레드만 동작할 수 있도록 동기화하여 이런 문제 해결할 수 있다
                - 동기화 하는 방법 = synchronized 키워드 사용
                  - Object 객체를 생성해서 sychonized에 매개변수에 입력하여 사용한다
                  - 따로 객체생성하지 않고 메서드가 구현된 객체를 매개변수에 입력하여 사용한다
                  - 사용 메서드에 synchronized 키워드를 사용한다 (메서드 구현된 객체를 lock으로 사용한다)
                    - 사용하는 부분에만 sychonized를 하는게 최적화를 위해 가장 좋은 방식이라고 하였다.
                  - 메서드를 사용하는 곳에 synchronized를 사용 한다
                - wait, notify로 동기화된 객체들을
                  - notify =>: 일시 정지 상태에 있는 다른 스레드를 실행 대기 상태로 만든다
                    - nitifyAll은 일시 정지 상태에 있는 다른 모든 스레드를 실행 대기 상태로 만든다
                  - wait() => lock을 소유하고 있는 스레드가 lock을 반납하고 일시 정지 상태가 된다
                  - 참고1: https://cornswrold.tistory.com/189
                  -  참고2:https://javaplant.tistory.com/29

          

        - day1 분량을 실습과 함께 따로 정리하면서 부족한 부분은 자료를 찾아가면서 공부해봤는데 이해하는데 도움이 많이 됬다

          - 내일 오전 시간활용해서 day2 복습하고 저녁시간 활용해서 day4 복습할 수 있으면 좋겠다

          

    

  # 공부하면서 느낀점

- 오전 9시 수업이 생기면서 피로가 쌓였는지 어제 오늘은 수업시간에 많이 졸았다. 이렇게 수업시간에 졸아서 내용에 집중을 못할 거면 일찍다니는게 크게 의미가 없는 것 같다. 얼마만큼 쉬어주어야 내가 하루동안의 활동에 집중할 수 있는지 관찰하고 세팅하는게 중요할 것 같다
- 강의 보며 기록한것 위주로 보면서 복습했는데 코드와 동떨어져서 복습이 이루어지는 것으로 느껴져서 코드를 보고 그다음 이해안되거나 보충할 부분을 기록한것을 보는 식으로 진행을 했다

  - 텍스트로 기록할 부분들은 간결하게 정리하고 코드를 직접 사용하면서 공부하는 방식이 더효율적일 것 같다

- 멀티스레드 복습하는데 수업이빡빡해서 바로바로 복습 못했더니 어떤 내용했는지 기억이 잘안나서 복습이 더 오래걸린다. 바로바로 복습하도록 스케쥴 잡아 보자
  
- 자료찾아 볼때 영어자료 우선으로 봐야하는데 시간 오래걸리니 어려우니 나중에 자료 없을 때 찾아보자고 생각한다... 어차피 해야하는것 지금부터 시작해야 나중에 수월하게 한다
  
    

# 내일 공부할 내용

- java 보강 수업 복습
- TiL 정리 및 블로그 업데이트







